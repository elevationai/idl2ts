// Test case for type name ambiguity resolution
// This tests the specific case we encountered with MediaType

module Ambiguity {
  // Top-level interface named ConfigType
  interface ConfigType {
    string getName();
    long getVersion();
    boolean isValid();
  };
  
  // Another interface with a nested enum of the same name
  interface ConfigManager {
    // Nested enum with same name as top-level interface
    enum ConfigType {
      PRODUCTION,
      STAGING,
      DEVELOPMENT,
      TESTING
    };
    
    // Nested struct that uses the enum
    struct ConfigInfo {
      ConfigType type;  // Should refer to the enum
      string environment;
      long version;
    };
    
    // Methods using both types
    ConfigType getCurrentType();  // Should return the enum
    void setType(in ConfigType type);  // Should take the enum
    ConfigInfo getConfigInfo();
    
    // Method using the top-level interface
    ConfigType loadConfiguration();  // Ambiguous - parser should resolve to enum in this context
  };
  
  // Another interface that needs to reference both
  interface ConfigService {
    // Should reference the top-level interface
    ConfigType getConfigInterface();
    
    // Should reference the nested enum
    ::Ambiguity::ConfigManager::ConfigType getManagerType();
    
    // Uses both in parameters
    void processConfig(
      in ConfigType configInterface,  // Top-level interface
      in ::Ambiguity::ConfigManager::ConfigType managerType  // Nested enum
    );
  };
  
  // Test with multiple levels of nesting
  interface Container {
    enum Status { IDLE, RUNNING, STOPPED };
    
    interface Nested {
      enum Status { PENDING, ACTIVE, COMPLETE };
      
      Status getStatus();  // Should refer to Nested::Status
      ::Ambiguity::Container::Status getContainerStatus();
    };
    
    Status getStatus();  // Should refer to Container::Status
    Nested getNested();
  };
}

// Additional module to test cross-module ambiguity
module External {
  // Reference to ambiguous types from another module
  interface ExternalService {
    // Should resolve to the interface
    ::Ambiguity::ConfigType getConfig();
    
    // Should resolve to the enum
    ::Ambiguity::ConfigManager::ConfigType getType();
    
    // Struct using external types
    struct ExternalConfig {
      ::Ambiguity::ConfigType config;  // Interface
      ::Ambiguity::ConfigManager::ConfigType type;  // Enum
    };
    
    ExternalConfig getExternalConfig();
  };
}
import * as AST from '../ast/nodes.js';
import * as fs from 'node:fs';
import * as path from 'node:path';

interface ExtendedNode {
  __sourceModule?: string;
  __sourceInterface?: string;
}

export interface GeneratorOptions {
  includeStubs?: boolean;
  includeSkeletons?: boolean;
  emitHelpers?: boolean;
  sourceFile?: string;
  corbaImportPath?: string; // Custom import path for CORBA
}

interface ModuleOutput {
  name: string;
  content: string[];
  imports: Set<string>; // Track dependencies on other modules
  typeImports: Set<string>; // Track type-only imports
  usesCorba: boolean; // Track if CORBA is used for values
  usesCorbaTypes: boolean; // Track if CORBA is used for types
  definitions: AST.DefinitionNode[]; // Store the AST definitions for lookup
}

export class TypeScriptGenerator {
  private options: GeneratorOptions;
  private indentLevel: number = 0;
  private output: string[] = [];
  private currentModulePrefix: string = '';
  private currentModule: string = ''; // Track current module for multi-file
  private modules: Map<string, ModuleOutput> = new Map();
  private rootModule: ModuleOutput | null = null;
  private nestedTypes: Map<string, string> = new Map(); // Maps nested type to parent_type
  private currentModuleOutput: ModuleOutput | null = null; // Current module being generated

  constructor(options: GeneratorOptions = {}) {
    this.options = {
      includeStubs: true,
      includeSkeletons: false,
      emitHelpers: true,
      corbaImportPath: 'corba', // Default CORBA import (use import map for Deno)
      ...options
    };
  }

  private addImport(moduleName: string, isTypeOnly: boolean = false): void {
    if (this.currentModuleOutput) {
      if (isTypeOnly) {
        this.currentModuleOutput.typeImports.add(moduleName);
      } else {
        this.currentModuleOutput.imports.add(moduleName);
      }
    }
  }

  private markCorbaUsed(): void {
    if (this.currentModuleOutput) {
      this.currentModuleOutput.usesCorba = true;
    }
  }

  private markCorbaTypeUsed(): void {
    if (this.currentModuleOutput) {
      this.currentModuleOutput.usesCorbaTypes = true;
    }
  }

  private resolveTypeName(typeName: string, isTypeOnly: boolean = false): string {
    if (typeName.includes('::')) {
      // Handle global scope references like ::Module::Type
      let parts = typeName.split('::');

      // Remove empty first element if starts with ::
      if (parts[0] === '') {
        parts = parts.slice(1);
      }

      if (parts.length >= 2) {
        const moduleName = parts[0];
        const type = parts.slice(1).join('_');
        if (moduleName !== this.currentModule) {
          this.addImport(moduleName, isTypeOnly);
          return `${moduleName}.${type}`;
        }
        return type;
      }
    }
    return this.getPrefixedName(typeName);
  }

  generate(ast: AST.SpecificationNode): Map<string, string> {
    this.output = [];
    this.indentLevel = 0;
    this.modules.clear();
    this.currentModule = '';

    // Initialize root module for top-level definitions
    this.rootModule = {
      name: '_root',
      content: [],
      imports: new Set<string>(),
      typeImports: new Set<string>(),
      usesCorba: false,
      usesCorbaTypes: false,
      definitions: ast.definitions
    };
    this.currentModuleOutput = this.rootModule;

    // Process all definitions
    for (const def of ast.definitions) {
      this.generateDefinition(def);
    }

    // Generate output for each module
    const outputFiles = new Map<string, string>();

    // Process root module if it has content
    if (this.rootModule.content.length > 0) {
      const rootOutput = this.generateModuleFile(this.rootModule, 'index');
      outputFiles.set('index.ts', rootOutput);
    }

    // Process named modules
    for (const [name, module] of this.modules) {
      const moduleOutput = this.generateModuleFile(module, name);
      outputFiles.set(`${name}.ts`, moduleOutput);
    }

    return outputFiles;
  }

  private generateModuleFile(module: ModuleOutput, moduleName: string): string {
    const lines: string[] = [];

    // Get version from package.json
    let version = 'unknown';
    try {
      const packageJsonPath = path.join(__dirname, '../../package.json');
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
      version = packageJson.version || 'unknown';
    } catch (e) {
      // If we can't read package.json, use unknown
    }

    // Add header comment
    lines.push("/**");
    lines.push(" * This file was automatically generated by idl2ts");
    lines.push(" * DO NOT EDIT THIS FILE DIRECTLY");
    lines.push(" *");
    lines.push(` * Source: ${this.options.sourceFile || 'unknown'}`);
    if (moduleName !== 'index') {
      lines.push(` * Module: ${moduleName}`);
    }
    lines.push(" * Generated on: " + new Date().toISOString());
    lines.push(` * idl2ts version: ${version}`);
    lines.push(" */");
    lines.push("");

    // Add CORBA import only if needed
    if (module.usesCorba && module.usesCorbaTypes) {
      // Both value and type usage - separate type and value imports
      lines.push(`import type { TypeCode } from "${this.options.corbaImportPath || 'corba'}";`);
      lines.push(`import { CORBA, create_request } from "${this.options.corbaImportPath || 'corba'}";`);
    } else if (module.usesCorbaTypes) {
      // Type-only usage
      lines.push(`import type { CORBA } from "${this.options.corbaImportPath || 'corba'}";`);
    } else if (module.usesCorba) {
      // Value-only usage (rare but possible)
      lines.push(`import type { TypeCode } from "${this.options.corbaImportPath || 'corba'}";`);
      lines.push(`import { create_request } from "${this.options.corbaImportPath || 'corba'}";`);
    }

    // Add imports from other modules
    // Handle type-only imports
    if (module.typeImports.size > 0) {
      for (const imp of module.typeImports) {
        // Check if this module is also imported for values
        if (!module.imports.has(imp)) {
          lines.push(`import type * as ${imp} from "./${imp}.ts";`);
        }
      }
    }

    // Handle value imports (which can also be used for types)
    if (module.imports.size > 0) {
      for (const imp of module.imports) {
        lines.push(`import * as ${imp} from "./${imp}.ts";`);
      }
    }

    // Add empty line after imports if any were added
    const hasImports = module.usesCorba || module.usesCorbaTypes ||
                       module.imports.size > 0 || module.typeImports.size > 0;
    if (hasImports) {
      lines.push("");
    }

    // Add module content
    for (const line of module.content) {
      lines.push(line);
    }

    return lines.join('\n');
  }


  private generateDefinition(node: AST.DefinitionNode): void {
    switch (node.kind) {
      case 'module':
        this.generateModule(node);
        break;
      case 'interface':
        this.generateInterface(node);
        break;
      case 'struct':
        this.generateStruct(node);
        break;
      case 'union':
        this.generateUnion(node);
        break;
      case 'enum':
        this.generateEnum(node);
        break;
      case 'typedef':
        this.generateTypedef(node);
        break;
      case 'constant':
        this.generateConstant(node);
        break;
      case 'exception':
        this.generateException(node);
        break;
    }
  }

  private generateModule(node: AST.ModuleNode): void {
    // Save current context
    const savedOutput = this.output;
    const savedModule = this.currentModule;
    const savedPrefix = this.currentModulePrefix;
    const savedNestedTypes = new Map(this.nestedTypes);

    // Get or create module (handle module reopening)
    this.currentModule = node.name;
    let moduleOutput = this.modules.get(node.name);
    if (!moduleOutput) {
      moduleOutput = {
        name: node.name,
        content: [],
        imports: new Set<string>(),
        typeImports: new Set<string>(),
        usesCorba: false,
        usesCorbaTypes: false,
        definitions: []
      };
      this.modules.set(node.name, moduleOutput);
    }

    // Merge definitions (module reopening)
    moduleOutput.definitions.push(...node.definitions);
    this.output = moduleOutput.content;
    this.currentModuleOutput = moduleOutput;
    this.currentModulePrefix = ''; // No prefix in multi-file mode
    this.nestedTypes.clear(); // Clear nested types for new module

    // Generate module content
    for (const def of node.definitions) {
      this.generateDefinition(def);
    }

    // Restore context
    this.output = savedOutput;
    this.currentModule = savedModule;
    this.currentModulePrefix = savedPrefix;
    this.nestedTypes = savedNestedTypes;
    this.currentModuleOutput = savedModule ? this.modules.get(savedModule) || this.rootModule : this.rootModule;
  }

  private generateInterface(node: AST.InterfaceNode): void {
    // First, extract and generate any nested types with prefixed names
    for (const member of node.members) {
      if (member.kind === 'enum' || member.kind === 'struct' ||
          member.kind === 'typedef' || member.kind === 'constant' ||
          member.kind === 'exception' || member.kind === 'union') {
        // Generate nested type at module level with parent interface prefix
        const nestedDef = member as AST.DefinitionNode;
        const originalName = (nestedDef as any).name;
        if (originalName) {
          const prefixedName = `${node.name}_${originalName}`;
          // Track this as a nested type
          this.nestedTypes.set(originalName, prefixedName);
          // Temporarily rename for generation
          (nestedDef as any).name = prefixedName;
          this.generateDefinition(nestedDef);
          // Restore original name
          (nestedDef as any).name = originalName;
        } else {
          this.generateDefinition(nestedDef);
        }
      }
    }

    const name = this.getPrefixedName(node.name);
    let inheritance = '';
    if (node.inheritance && node.inheritance.length > 0) {
      inheritance = ` extends ${node.inheritance.map(i => this.resolveTypeName(i, true)).join(', ')}`;
    } else {
      inheritance = ' extends CORBA.ObjectRef';
      this.markCorbaTypeUsed();
    }

    this.emit(`export interface ${name}${inheritance} {`);
    this.indent();

    // Only generate operations and attributes in the interface body
    for (const member of node.members) {
      if (member.kind === 'operation') {
        this.generateOperation(member);
      } else if (member.kind === 'attribute') {
        this.generateAttribute(member);
      }
    }

    this.dedent();
    this.emit('}');
    this.emit('');

    if (this.options.includeStubs) {
      this.generateClientStub(node);
    }

    if (this.options.includeSkeletons) {
      this.generateServerSkeleton(node);
    }
  }

  private generateOperation(node: AST.OperationNode): void {
    const params = node.parameters.map(p => {
      const paramName = p.direction === 'out' || p.direction === 'inout'
        ? `${p.name}?: ${this.mapType(p.type, true)}`
        : `${p.name}: ${this.mapType(p.type, true)}`;
      return paramName;
    }).join(', ');

    const returnType = node.isOneway
      ? 'Promise<void>'
      : `Promise<${this.mapType(node.returnType, true)}>`;

    this.emit(`${node.name}(${params}): ${returnType};`);
  }

  private generateAttribute(node: AST.AttributeNode): void {
    const tsType = this.mapType(node.type, true);

    if (node.isReadonly) {
      this.emit(`readonly ${node.name}: ${tsType};`);
      this.emit(`get_${node.name}(): Promise<${tsType}>;`);
    } else {
      this.emit(`${node.name}: ${tsType};`);
      this.emit(`get_${node.name}(): Promise<${tsType}>;`);
      this.emit(`set_${node.name}(value: ${tsType}): Promise<void>;`);
    }
  }

  private generateStruct(node: AST.StructNode): void {
    const name = this.getPrefixedName(node.name);
    this.emit(`export interface ${name} {`);
    this.indent();

    for (const member of node.members) {
      const tsType = this.mapType(member.type);
      this.emit(`${member.name}: ${tsType};`);
    }

    this.dedent();
    this.emit('}');
    this.emit('');
  }

  private generateUnion(node: AST.UnionNode): void {
    const name = this.getPrefixedName(node.name);
    this.emit(`export type ${name} =`);
    this.indent();

    const variants: string[] = [];
    for (const caseNode of node.cases) {
      if (caseNode.member) {
        const discriminatorValue = caseNode.isDefault
          ? '"default"'
          : caseNode.labels.map(l => JSON.stringify(l)).join(' | ');

        variants.push(`{ discriminator: ${discriminatorValue}; ${caseNode.member.name}: ${this.mapType(caseNode.member.type)} }`);
      }
    }

    // Output each variant on its own line with proper | formatting
    for (let i = 0; i < variants.length; i++) {
      if (i === variants.length - 1) {
        this.emit(`| ${variants[i]};`);
      } else {
        this.emit(`| ${variants[i]}`);
      }
    }
    this.dedent();
    this.emit('');
  }

  private generateEnum(node: AST.EnumNode): void {
    const name = this.getPrefixedName(node.name);
    this.emit(`export enum ${name} {`);
    this.indent();

    for (let i = 0; i < node.members.length; i++) {
      const member = node.members[i];
      this.emit(`${member} = ${i},`);
    }

    this.dedent();
    this.emit('}');
    this.emit('');
  }

  private generateTypedef(node: AST.TypedefNode): void {
    const name = this.getPrefixedName(node.name);
    const tsType = this.mapType(node.type);
    this.emit(`export type ${name} = ${tsType};`);
    this.emit('');
  }

  private generateConstant(node: AST.ConstantNode): void {
    const name = this.getPrefixedName(node.name);
    const tsType = this.mapType(node.type);

    let value: string | number | boolean = node.value;

    // Handle qualified constant references like ::Module::CONSTANT
    if (typeof node.value === 'string' && node.value.includes('::')) {
      let parts = node.value.split('::');

      // Remove empty first element if starts with ::
      if (parts[0] === '') {
        parts = parts.slice(1);
      }

      if (parts.length >= 2) {
        const moduleName = parts[0];
        const constName = parts.slice(1).join('_');
        if (moduleName !== this.currentModule) {
          // This is a cross-module constant reference, generate import
          this.addImport(moduleName, false); // Use regular import for values
          value = `${moduleName}.${constName}`;
        } else {
          // Same module reference
          value = constName;
        }
      }
    } else if (typeof value === 'string') {
      // Regular string literal - escape special characters for TypeScript
      // Order matters: escape special chars first, then backslashes, then quotes
      const escaped = value
        .replace(/\r/g, '\\r')     // Escape carriage returns
        .replace(/\n/g, '\\n')     // Escape newlines
        .replace(/\t/g, '\\t')     // Escape tabs
        .replace(/\\/g, '\\\\')    // Escape backslashes (must be after other escapes)
        .replace(/"/g, '\\"');     // Escape double quotes (last)
      value = `"${escaped}"`;
    }

    this.emit(`export const ${name}: ${tsType} = ${value};`);
    this.emit('');
  }

  private generateException(node: AST.ExceptionNode): void {
    const name = this.getPrefixedName(node.name);
    this.emit(`export class ${name} extends CORBA.SystemException {`);
    this.markCorbaUsed(); // Exception uses CORBA as value
    this.indent();

    for (const member of node.members) {
      const tsType = this.mapType(member.type);
      this.emit(`${member.name}: ${tsType};`);
    }

    this.emit('');
    this.emit(`constructor(${node.members.map(m => `${m.name}: ${this.mapType(m.type)}`).join(', ')}) {`);
    this.indent();
    this.emit(`super('${this.getPrefixedName(node.name)}');`);

    for (const member of node.members) {
      this.emit(`this.${member.name} = ${member.name};`);
    }

    this.dedent();
    this.emit('}');

    this.dedent();
    this.emit('}');
    this.emit('');
  }

  private generateClientStub(node: AST.InterfaceNode): void {
    const name = this.getPrefixedName(node.name);
    const moduleName = this.currentModule || 'IDL';
    const repositoryId = `IDL:${moduleName}/${node.name}:1.0`;

    this.emit(`export class ${name}_Stub extends CORBA.CorbaStub<${name}> implements ${name} {`);
    this.indent();

    // Static repository ID for narrow
    this.emit(`static readonly _repository_id = "${repositoryId}";`);
    this.emit('');

    // Constructor calls super
    this.emit('constructor(ref: CORBA.ObjectRef) {');
    this.indent();
    this.emit('super(ref);');
    this.dedent();
    this.emit('}');
    this.emit('');

    this.markCorbaUsed();
    this.markCorbaTypeUsed();

    // Collect all operations and attributes from this interface and its inheritance hierarchy
    const allMembers = this.collectInterfaceMembers(node);

    // Generate stub implementations for all members
    for (let i = 0; i < allMembers.length; i++) {
      const member = allMembers[i];
      if (member.kind === 'operation') {
        this.generateStubOperation(member, i < allMembers.length - 1);
      } else if (member.kind === 'attribute') {
        this.generateStubAttribute(member, i < allMembers.length - 1);
      }
    }

    this.dedent();
    this.emit('}');
    this.emit('');
  }

  private generateStubOperation(node: AST.OperationNode, addBlankLine: boolean = true): void {
    const sourceModule = (node as AST.OperationNode & ExtendedNode).__sourceModule;
    const sourceInterface = (node as AST.OperationNode & ExtendedNode).__sourceInterface;
    const params = node.parameters.map(p => {
      // Prefix unused parameters (out-only) with underscore to avoid lint warnings
      const paramName = (p.direction === 'out') ? `_${p.name}` : p.name;
      return `${paramName}: ${this.mapType(p.type, true, sourceModule, sourceInterface)}`;
    }).join(', ');

    const returnType = node.isOneway
      ? 'Promise<void>'
      : `Promise<${this.mapType(node.returnType, true, sourceModule, sourceInterface)}>`;

    this.emit(`async ${node.name}(${params}): ${returnType} {`);
    this.indent();

    this.emit(`const request = create_request(this._ref, "${node.name}");`);
    this.markCorbaUsed(); // Using CORBA.create_request function

    for (const param of node.parameters) {
      if (param.direction === 'in' || param.direction === 'inout') {
        this.emit(`request.add_named_in_arg("${param.name}", ${param.name}, undefined as unknown as TypeCode);`);
      }
      if (param.direction === 'out' || param.direction === 'inout') {
        this.emit(`request.add_out_arg(undefined as unknown as TypeCode);`);
      }
    }

    if (node.isOneway) {
      this.emit('request.send_oneway();');
    } else {
      this.emit('await request.invoke();');

      if (node.returnType.kind !== 'primitiveType' || node.returnType.type !== 'void') {
        const mappedType = this.mapType(node.returnType, true, (node as any).__sourceModule, (node as any).__sourceInterface);
        this.emit(`return request.return_value() as ${mappedType};`);
      }
    }

    this.dedent();
    this.emit('}');
    if (addBlankLine) {
      this.emit('');
    }
  }

  private generateStubAttribute(node: AST.AttributeNode, addBlankLine: boolean = true): void {
    const sourceModule = (node as AST.AttributeNode & ExtendedNode).__sourceModule;
    const sourceInterface = (node as AST.AttributeNode & ExtendedNode).__sourceInterface;
    const tsType = this.mapType(node.type, true, sourceModule, sourceInterface);

    this.emit(`async get_${node.name}(): Promise<${tsType}> {`);
    this.indent();
    this.emit(`const request = create_request(this._ref, "_get_${node.name}");`);
    this.markCorbaUsed(); // Using create_request function
    this.emit('await request.invoke();');
    this.emit(`return request.return_value() as ${tsType};`);
    this.dedent();
    this.emit('}');
    this.emit('');

    if (!node.isReadonly) {
      this.emit(`async set_${node.name}(value: ${tsType}): Promise<void> {`);
      this.indent();
      this.emit(`const request = create_request(this._ref, "_set_${node.name}");`);
      this.markCorbaUsed(); // Using create_request function
      this.emit(`request.add_named_in_arg("value", value, undefined as unknown as TypeCode);`);
      this.emit('await request.invoke();');
      this.dedent();
      this.emit('}');
      this.emit('');
    }

    this.emit(`get ${node.name}(): ${tsType} {`);
    this.indent();
    this.emit(`throw new Error("Direct property access not supported. Use get_${node.name}() instead.");`);
    this.dedent();
    this.emit('}');

    if (!node.isReadonly) {
      this.emit('');
      this.emit(`set ${node.name}(value: ${tsType}) {`);
      this.indent();
      this.emit(`throw new Error("Direct property access not supported. Use set_${node.name}() instead.");`);
      this.dedent();
      this.emit('}');
    }

    if (addBlankLine) {
      this.emit('');
    }
  }

  private generateServerSkeleton(node: AST.InterfaceNode): void {
    const name = this.getPrefixedName(node.name);
    this.emit(`export abstract class ${name}_POA extends CORBA.PortableServer.Servant implements ${name} {`);
    this.markCorbaUsed(); // POA uses CORBA as value
    this.indent();

    // Only process operations and attributes for skeleton
    for (const member of node.members) {
      if (member.kind === 'operation') {
        const params = member.parameters.map(p =>
          `${p.name}: ${this.mapType(p.type)}`
        ).join(', ');

        const returnType = member.isOneway
          ? 'Promise<void>'
          : `Promise<${this.mapType(member.returnType)}>`;

        this.emit(`abstract ${member.name}(${params}): ${returnType};`);
      } else if (member.kind === 'attribute') {
        const tsType = this.mapType(member.type);
        this.emit(`abstract get_${member.name}(): Promise<${tsType}>;`);

        if (!member.isReadonly) {
          this.emit(`abstract set_${member.name}(value: ${tsType}): Promise<void>;`);
        }

        this.emit(`get ${member.name}(): ${tsType} {`);
        this.indent();
        this.emit(`throw new Error("Direct property access not supported.");`);
        this.dedent();
        this.emit('}');

        if (!member.isReadonly) {
          this.emit(`set ${member.name}(value: ${tsType}) {`);
          this.indent();
          this.emit(`throw new Error("Direct property access not supported.");`);
          this.dedent();
          this.emit('}');
        }
      }
    }

    this.dedent();
    this.emit('}');
    this.emit('');
  }

  private mapType(node: AST.TypeNode, isTypeOnly: boolean = false, sourceModule?: string, sourceInterface?: string): string {
    switch (node.kind) {
      case 'primitiveType':
        return this.mapPrimitiveType(node.type);
      case 'namedType':
        // Check if this is a qualified name with ::
        if (node.name.includes('::')) {
          let parts = node.name.split('::');

          // Remove empty first element if starts with ::
          if (parts[0] === '') {
            parts = parts.slice(1);
          }

          if (parts.length >= 2) {
            const moduleName = parts[0];
            const typeName = parts.slice(1).join('_');
            if (moduleName !== this.currentModule) {
              this.addImport(moduleName, isTypeOnly);
              return `${moduleName}.${typeName}`;
            }
            return typeName;
          }
        }
        // Check if this is a nested type that was extracted
        if (this.nestedTypes.has(node.name)) {
          return this.nestedTypes.get(node.name)!;
        }


        // If we have a source module context, check there first
        if (sourceModule && sourceModule !== this.currentModule) {
          const sourceModuleOutput = this.modules.get(sourceModule);
          if (sourceModuleOutput) {
            // If we have interface context, prioritize nested types first
            if (sourceInterface) {
              const flattenedTypeName = this.findFlattenedType(node.name, sourceModuleOutput, sourceInterface);
              if (flattenedTypeName) {
                this.addImport(sourceModule, isTypeOnly);
                return `${sourceModule}.${flattenedTypeName}`;
              }
            }

            // Then try direct match
            if (this.typeExistsInModule(node.name, sourceModuleOutput)) {
              this.addImport(sourceModule, isTypeOnly);
              return `${sourceModule}.${node.name}`;
            }

            // Finally, try flattened types without interface preference
            if (!sourceInterface) {
              const flattenedTypeName = this.findFlattenedType(node.name, sourceModuleOutput);
              if (flattenedTypeName) {
                this.addImport(sourceModule, isTypeOnly);
                return `${sourceModule}.${flattenedTypeName}`;
              }
            }
          }
        }

        // For unqualified names, check if it exists in other imported modules
        // This handles the case where we're generating stubs with inherited types
        for (const [moduleName, module] of this.modules) {
          if (moduleName !== this.currentModule && this.typeExistsInModule(node.name, module)) {
            this.addImport(moduleName, isTypeOnly);
            return `${moduleName}.${node.name}`;
          }
        }

        // For unqualified names in the current module
        return this.getPrefixedName(node.name);
      case 'sequenceType':
        return `${this.mapType(node.elementType, isTypeOnly, sourceModule, sourceInterface)}[]`;
      case 'arrayType':
        const baseType = this.mapType(node.elementType, isTypeOnly, sourceModule, sourceInterface);
        return node.dimensions.reduce((type) => `${type}[]`, baseType);
      case 'stringType':
        return 'string';
      case 'fixedType':
        return 'number';
      default:
        return 'unknown';
    }
  }

  private mapPrimitiveType(type: string): string {
    const mapping: Record<string, string> = {
      'void': 'void',
      'boolean': 'boolean',
      'char': 'string',
      'wchar': 'string',
      'octet': 'number',
      'short': 'number',
      'unsigned short': 'number',
      'long': 'number',
      'unsigned long': 'number',
      'long long': 'bigint',
      'unsigned long long': 'bigint',
      'float': 'number',
      'double': 'number',
      'long double': 'number',
      'any': 'unknown',
      'Object': 'CORBA.ObjectRef'  // Use ObjectRef which is defined in CORBA namespace
    };

    // Mark CORBA as used only when Object type is actually used
    if (type === 'Object') {
      this.markCorbaTypeUsed();
    }

    return mapping[type] || 'unknown';
  }

  private emit(line: string): void {
    const target = this.currentModule && this.modules.has(this.currentModule)
      ? this.modules.get(this.currentModule)!.content
      : this.rootModule && !this.currentModule
      ? this.rootModule.content
      : this.output;

    if (line) {
      target.push(this.getIndent() + line);
    } else {
      target.push('');
    }
  }

  private indent(): void {
    this.indentLevel++;
  }

  private dedent(): void {
    this.indentLevel--;
  }

  private getIndent(): string {
    return '  '.repeat(this.indentLevel);
  }

  private getPrefixedName(name: string): string {
    // No prefixing in multi-file mode
    return name;
  }

  private collectInterfaceMembers(node: AST.InterfaceNode, sourceModule?: string): (AST.OperationNode | AST.AttributeNode)[] {
    const members: (AST.OperationNode | AST.AttributeNode)[] = [];

    // Add direct members from this interface
    for (const member of node.members) {
      if (member.kind === 'operation' || member.kind === 'attribute') {
        // Tag the member with its source module and interface if it's from a different context
        const memberCopy = { ...member } as (AST.OperationNode | AST.AttributeNode) & ExtendedNode;
        if (sourceModule && sourceModule !== this.currentModule) {
          memberCopy.__sourceModule = sourceModule;
          memberCopy.__sourceInterface = node.name; // Track which interface originally defined this member
        }
        members.push(memberCopy as AST.OperationNode | AST.AttributeNode);
      }
    }

    // Recursively collect from inherited interfaces
    if (node.inheritance && node.inheritance.length > 0) {
      for (const inheritedName of node.inheritance) {
        const inheritedInterface = this.findInterface(inheritedName);
        if (inheritedInterface) {
          // Determine source module for inherited interface
          let inheritedSourceModule = sourceModule;
          if (inheritedName.includes('::') || inheritedName.includes('.')) {
            const separator = inheritedName.includes('::') ? '::' : '.';
            inheritedSourceModule = inheritedName.split(separator)[0];
          }

          const inheritedMembers = this.collectInterfaceMembers(inheritedInterface, inheritedSourceModule);
          members.unshift(...inheritedMembers); // Add inherited members first
        }
      }
    }

    return members;
  }

  private findInterface(name: string): AST.InterfaceNode | null {
    // Handle qualified names like "Characteristics::Capture" (IDL) or "Characteristics.Capture" (TypeScript)
    if (name.includes('::') || name.includes('.')) {
      const separator = name.includes('::') ? '::' : '.';
      const parts = name.split(separator);
      const moduleName = parts[0];
      const interfaceName = parts[1];

      // Search in the specified module
      if (this.modules.has(moduleName)) {
        const module = this.modules.get(moduleName)!;
        return this.findInterfaceInDefinitions(interfaceName, module.definitions);
      }

      return null;
    }

    // Search in current module first
    if (this.currentModule && this.modules.has(this.currentModule)) {
      const module = this.modules.get(this.currentModule)!;
      const found = this.findInterfaceInDefinitions(name, module.definitions);
      if (found) return found;
    }

    // Search in all other modules (prioritizing imported modules)
    if (this.currentModuleOutput) {
      // First search in explicitly imported modules
      for (const importedModule of this.currentModuleOutput.imports) {
        if (this.modules.has(importedModule)) {
          const module = this.modules.get(importedModule)!;
          const found = this.findInterfaceInDefinitions(name, module.definitions);
          if (found) return found;
        }
      }

      // Also search in type-only imports
      for (const importedModule of this.currentModuleOutput.typeImports) {
        if (this.modules.has(importedModule)) {
          const module = this.modules.get(importedModule)!;
          const found = this.findInterfaceInDefinitions(name, module.definitions);
          if (found) return found;
        }
      }
    }

    // Search in all other modules
    for (const [moduleName, module] of this.modules) {
      if (moduleName !== this.currentModule) {
        const found = this.findInterfaceInDefinitions(name, module.definitions);
        if (found) return found;
      }
    }

    // Search in root module if we have one
    if (this.rootModule) {
      return this.findInterfaceInDefinitions(name, this.rootModule.definitions);
    }

    return null;
  }

  private findInterfaceInDefinitions(name: string, definitions: AST.DefinitionNode[]): AST.InterfaceNode | null {
    for (const def of definitions) {
      if (def.kind === 'interface' && (def as AST.InterfaceNode).name === name) {
        return def as AST.InterfaceNode;
      }
    }
    return null;
  }

  private typeExistsInModule(typeName: string, module: ModuleOutput): boolean {
    for (const def of module.definitions) {
      if ((def.kind === 'enum' && (def as AST.EnumNode).name === typeName) ||
          (def.kind === 'typedef' && (def as AST.TypedefNode).name === typeName) ||
          (def.kind === 'struct' && (def as AST.StructNode).name === typeName) ||
          (def.kind === 'union' && (def as AST.UnionNode).name === typeName) ||
          (def.kind === 'interface' && (def as AST.InterfaceNode).name === typeName)) {
        return true;
      }
    }

    // Also check for flattened nested types like InterfaceName_TypeName
    // This handles cases where typeName is a nested type that was flattened to module level
    for (const def of module.definitions) {
      if (def.kind === 'interface') {
        const interfaceDef = def as AST.InterfaceNode;
        // Check if any nested types in this interface match the pattern ParentName_TypeName
        for (const member of interfaceDef.members) {
          const expectedFlattenedName = `${interfaceDef.name}_${member.name}`;
          if (expectedFlattenedName === typeName) {
            if (member.kind === 'enum' ||
                member.kind === 'struct' ||
                member.kind === 'union' ||
                member.kind === 'typedef' ||
                member.kind === 'exception') {
              return true;
            }
          }
        }
      }
    }

    return false;
  }

  private findFlattenedType(typeName: string, module: ModuleOutput, preferredInterface?: string): string | null {
    // Look for flattened nested types like InterfaceName_TypeName where TypeName matches our target

    // If we have a preferred interface (source context), check there first
    if (preferredInterface) {
      for (const def of module.definitions) {
        if (def.kind === 'interface' && (def as AST.InterfaceNode).name === preferredInterface) {
          const interfaceDef = def as AST.InterfaceNode;
          for (const member of interfaceDef.members) {
            if (member.name === typeName) {
              if (member.kind === 'enum' ||
                  member.kind === 'struct' ||
                  member.kind === 'union' ||
                  member.kind === 'typedef' ||
                  member.kind === 'exception') {
                return `${interfaceDef.name}_${typeName}`;
              }
            }
          }
        }
      }
    }

    // If not found in preferred interface, collect all possible matches
    const allMatches: string[] = [];
    for (const def of module.definitions) {
      if (def.kind === 'interface') {
        const interfaceDef = def as AST.InterfaceNode;
        // Skip the preferred interface since we already checked it
        if (preferredInterface && interfaceDef.name === preferredInterface) {
          continue;
        }
        for (const member of interfaceDef.members) {
          if (member.name === typeName) {
            if (member.kind === 'enum' ||
                member.kind === 'struct' ||
                member.kind === 'union' ||
                member.kind === 'typedef' ||
                member.kind === 'exception') {
              allMatches.push(`${interfaceDef.name}_${typeName}`);
            }
          }
        }
      }
    }

    // If multiple matches, prefer enum types over interface types
    // This handles the MediaOutput_MediaType vs MediaType case
    if (allMatches.length > 0) {
      // Check if any of the matches correspond to enum types (they will be shorter typically)
      // For MediaOutput_MediaType vs MediaType, prefer the nested enum
      return allMatches[0]; // Return first match for now, can be enhanced with better heuristics
    }

    return null;
  }
}
